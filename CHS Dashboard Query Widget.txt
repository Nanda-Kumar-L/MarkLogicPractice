0) Total available appointment slots for loading    - X day(user to select)

declare variable $days as xs:integer external;

let $current-date := current-dateTime()
let $end-date := $current-date + xs:dayTimeDuration(concat('P', xs:int($days), 'D'))

let $appointments :=
  for $appointment in collection("Appointment")/Appointments/Appointment
  where $appointment/AppointmentType = "Load" 
        and xs:dateTime($appointment/ScheduledStartDateTime) >= $current-date
        and xs:dateTime($appointment/ScheduledEndDateTime) <= $end-date
  return $appointment

let $total-appointments := count($appointments)

return
  element result {
    element totalAppointments { $total-appointments },
    for $appointment in $appointments
    return element appointment {
      element AppointmentId { $appointment/AppointmentId/text() },
      element ScheduledStartDateTime { $appointment/ScheduledStartDateTime },
      element ScheduledEndDateTime { $appointment/ScheduledEndDateTime }
    }
  }











1) Loading Appointment attached to 'A' Vessel - Group by Vessel Line Up

let $Appointments := collection('Appointment')
let $vessels := collection('Vessel Line Up Inventory')

return element result{
for $lineup in fn:distinct-values($vessels//LineUpId)
let $vessel := $vessels[.//LineUpId eq $lineup]
let $appointment := $Appointments[.//AppointmentId eq $vessel//LoadingAppointmentId]
let $appointmentId := $appointment//AppointmentId
let $ScheduledStartDateTime := $appointment/ScheduledStartDateTime
let $ScheduleEndDateTime := $appointment/ScheduledEndDateTime
return (element Lineup{$lineup},
    element Appointment{$appointmentId,$ScheduledStartDateTime,$ScheduleEndDateTime})
}

















2) Appointment attached to  Vessel / Vessel Line up but late for appointment  

let $currentDate := fn:current-dateTime()

let $Appointments := collection('Appointment')
let $Vessels := collection('Vessel Lineup Inventory')
let $lateAppointments :=
  for $vessel in $Vessels
  let $vesselId := $vessel//VesselId
  let $lineUpId := $vessel//LineUpId
  return 
  element vessel
  {
    $vesselId,$lineUpId,
    for $appointment in $Appointments
      let $appointmentId := $appointment//AppointmentId
      let $scheduledStartDateTime := $appointment//ScheduledStartDateTime
      let $scheduledEndDateTime := $appointment//ScheduledEndDateTime
      where $appointment/AppointmentType = "Load" and $appointment//AppointmentId = $vessel//AppointmentId
            and xs:dateTime($appointment//actualCheckInDateTime) > $currentDate
      return
        element Appointment { $appointmentId,$scheduledStartDateTime,$scheduledEndDateTime }
  }
return element result { $lateAppointments }

















3) Shipments that are impacted by weather disruptions 

let $impactedShipments :=
  for $shipment in fn:collection("Shipments and Inventory")
  let $routeId := $shipment/RouteId/text()
  let $inventoryId := $shipment/InventoryId/text()
  let $inventoryType := $shipment/InventoryType/text()
  let $weatherDisruption := fn:collection("Weather Disruption")//Disruption[Zip eq $routeId]
  let $riverDisruption := fn:collection("River Disruption")//Disruption[RiverLocation eq $routeId]
  where exists($weatherDisruption) or exists($riverDisruption)
  return
    if ((exists($weatherDisruption) and $weatherDisruption/DisruptionStatus != "Normal") or
       (exists($riverDisruption) and $riverDisruption/DisruptionStatus != "Normal"))
    then
      element Shipment {
        element InventoryId { $inventoryId },
        element InventoryType { $inventoryType },
        element RouteId { $routeId },
        element WeatherDisruptionStatus { $weatherDisruption/DisruptionStatus },
        element RiverDisruptionStatus { $riverDisruption/DisruptionStatus }
      }
    else ()

let $Confirmed :=
  
    for $impactedShipment in $impactedShipments
    let $inventoryId := $impactedShipment/InventoryId
    let $AppointmentIds := 
      for $i in $impactedShipment//AppointmentId
      where $i/../AppointmentStatus eq 'Confirmed'
      return $i
    where count($AppointmentIds) eq 1
    return element appointment{$inventoryId,$AppointmentIds}
    

return
  element Result {
    element ImpactedShipments { $impactedShipments },
    element CancelledCount { count($Confirmed) },
    element ConfirmedAppointments {$Confirmed} 
  }














4) Total Appointments rescheduled more than once 

let $rescheduledAppointments :=
  for $appointment in fn:collection("Appointment")
  let $inventoryId := collection("Shipments and Inventory")[.//AppointmentId eq $appointment//AppointmentId]/InventoryId/text()
  let $appointmentId := $appointment/AppointmentId/text()
  let $status := $appointment/AppointmentStatus/text()
  where $status = "Cancelled"
  return
    if (count($appointment[InventoryId eq $inventoryId and AppointmentStatus eq "Confirmed"]) > 1)
    then
      element Appointment {
        element InventoryId { $inventoryId },
        element AppointmentId { $appointmentId },
        element RescheduleCount { count($appointment[InventoryId eq $inventoryId and AppointmentStatus eq "Confirmed"]) - 1}
      }
    else ()

return
  element Result {
    element RescheduledAppointments { $rescheduledAppointments }
  }
















5) Appointment not loaded before Xhrs of vessel departure time:
4hrs before appt
3hrs before appt
2hrs before appt
1hr  before appt

let $appointments :=
  for $appointment in collection("Appointment")
  let $vesselId := $appointment/VesselId
  let $vesselName := $appointment/VesselName
  let $inventoryId := $appointment/InventoryId
  let $scheduleStartDate := $appointment/ScheduleStartDate
  let $scheduleEndDate := $appointment/ScheduleEndDate
  let $appointmentId := $appointment/AppointmentId
  let $appointmentType := $appointment/AppointmentType
  let $appointmentStatus := $appointment/AppointmentStatus
  let $vesselJourney := collection("Vessel Journey")//Vessel[Id eq $vesselId]
  let $ExpectedVesselOriginDepartureDateTime := $vesselJourney/ExpectedVesselOriginDepartureDateTime
  where $appointmentType eq "Load" and $appointmentStatus eq "Confirmed"
  return
    if (fn:exists($vesselJourney) and $ExpectedVesselOriginDepartureDateTime gt $scheduleStartDate)
    then
      element Appointment { $appointmentId, $inventoryId, $scheduleStartDate, $scheduleEndDate, $vesselId, $vesselName, $ExpectedVesselOriginDepartureDateTime }
    else ()

let $appointments4HrsBefore := $appointments[xs:dateTime(ExpectedVesselOriginDepartureDateTime) le xs:dateTime(ScheduleStartDateTime) - xs:dayTimeDuration('PT4H')]
let $appointments3HrsBefore := $appointments[xs:dateTime(ExpectedVesselOriginDepartureDateTime) le xs:dateTime(ScheduleStartDateTime) - xs:dayTimeDuration('PT3H')]
let $appointments2HrsBefore := $appointments[xs:dateTime(ExpectedVesselOriginDepartureDateTime) le xs:dateTime(ScheduleStartDateTime) - xs:dayTimeDuration('PT2H')]
let $appointments1HrBefore := $appointments[xs:dateTime(ExpectedVesselOriginDepartureDateTime) le xs:dateTime(ScheduleStartDateTime) - xs:dayTimeDuration('PT1H')]

return
  element Result {
    element Appointments4HrsBefore { $appointments4HrsBefore },
    element Appointments3HrsBefore { $appointments3HrsBefore },
    element Appointments2HrsBefore { $appointments2HrsBefore },
    element Appointments1HrBefore { $appointments1HrBefore }
  }












6)Total Barges/Trucks/Rail Arrrived but not checked in more than Xhrs

declare function local:waiting-hours($arrival as xs:dateTime) as xs:double {
  let $currentDateTime := fn:current-dateTime()
  return xs:double($currentDateTime - $arrival) div 3600
};


let $results :=
  for $shipment in fn:collection("ShipmentsAndInventory")
  let $inventoryId := $shipment/InventoryId
  let $inventoryType := $shipment/InventoryType
  let $arrivalDateTime := xs:dateTime($shipment/ActualShipmentDestinationArrivalDateTime)
  let $waitingHours := local:waiting-hours($arrivalDateTime)
  let $appointment :=
    for $appt in fn:collection("Appointment")
    where $appt/InventoryId eq $inventoryId and $appt/AppointmentStatus eq "Confirmed"
    return $appt
  where fn:exists($appointment) and $shipment/ShipmentStatus eq "Arrived"
  return
    element object {
      element InventoryId { $inventoryId },
      element InventoryType { $inventoryType },
      element ActualShipmentDestinationArrivalDateTime { $arrivalDateTime },
      element WaitingHours { $waitingHours }
    }


let $groupedResults :=
  for $type in fn:distinct-values($results/InventoryType)
  let $filteredResults := $results[InventoryType eq $type]
  let $count := fn:count($filteredResults)
  return
    element object {
      element InventoryType { $type },
      element CountOfInventoryId { $count },
      element Details { $filteredResults }
    }

return element Result { $groupedResults }



















7)Total Barges/Trucks/Rail partially unloaded with idle time(waiting time since the arrival)


declare function local:idle-time($checkedIn as xs:dateTime) as xs:double {
  let $currentDateTime := fn:current-dateTime()
  return xs:double($currentDateTime - $checkedIn) div 86400 
};


let $results :=
  for $shipment in fn:collection("ShipmentsAndInventory")
  let $inventoryId := $shipment/InventoryId
  let $inventoryType := $shipment/InventoryType
  let $arrivalDateTime := xs:dateTime($shipment/ActualShipmentDestinationArrivalDateTime)
  let $checkedInDateTime := xs:dateTime($shipment/CheckedInDateTime)
  let $idleTime := local:idle-time($checkedInDateTime)
  where $shipment/ShipmentStatus eq "Partially Unloaded"
  return
    element object {
      element InventoryId { $inventoryId },
      element InventoryType { $inventoryType },
      element ActualShipmentDestinationArrivalDateTime { $arrivalDateTime },
      element ShipmentStatus { $shipment/ShipmentStatus },
      element IdleTimeInDays { $idleTime }
    }


let $groupedResults :=
  for $type in fn:distinct-values($results/InventoryType)
  let $filteredResults := $results[InventoryType eq $type]
  let $count := fn:count($filteredResults)
  return
    element object {
      element InventoryType { $type },
      element CountOfInventoryId { $count },
      element Details { $filteredResults }
    }
 
return element Result { $groupedResults }

















8)Total Appointments to be loaded for a given vessel line up 

xquery version "1.0-ml";

element result{
  for $i in collection("VesselLineupBlend")
  let $lineupId := $i//lineupId
  let $appointmentIds := 
    for $Appointment in collection("Appointments")//Appointment
    where $Appointment//$lineupId eq $lineupId and $Appointment/AppointmentStatus eq 'Confirmed' and $Appointment/AppointmentType eq 'Load'
    return $Appointment
  return element lineupId{$lineupId, element count{count($appointmentIds)}}
}
















9)Potential contract voilation if "Y" appointments are not loaded in Xhrs 


let $currentDateTime := current-dateTime()


let $appointments := 
    for $appt in collection("Appointment")
    where $appt/AppointmentStatus eq "Confirmed"
    and $appt/AppointmentType eq "Load"
    and $currentDateTime > xs:dateTime($appt/ScheduledEndDateTime) + xs:dayTimeDuration("PT5H")
    return $appt

 
for $appt in $appointments
let $vesselLineupBlend := collection("VesselLineUpBlend")/VesselLineUpBlend[VesselId eq $appt/VesselId]
return
    element object {
        element "VesselId" { $vesselLineupBlend/VesselId },
        element "LineupId" { $vesselLineupBlend/LineupId },
        element "Appointment" {
            element "AppointmentId" { $appt/AppointmentId },
            element "ScheduledStartDateTime" { $appt/ScheduledStartDateTime },
            element "ScheduledEndDateTime" { $appt/ScheduledEndDateTime },
            element "NoOfHoursCrossedScheduledEndDateTime" {
                hours-from-duration(
                    $currentDateTime - xs:dateTime($appt/ScheduledEndDateTime)
                )
            }
        }
    }














10)Total Appointments for X date

let $currentDate := fn:current-date()

let $results :=
  for $appointment in fn:collection("Appointment")
  where fn:starts-with($appointment/ScheduledStartDate/text(), $currentDate)
  let $appointmentType := $appointment/AppointmentType/text()
  let $equipmentType := $appointment/EquipmentType/text()
  return
    element object {
      element AppointmentType { $appointmentType },
      element EquipmentType { $equipmentType },
      element ScheduleStartDate { $appointment/ScheduledStartDate/text() }
    }

 
let $groupedResults :=
  for $type in fn:distinct-values($results/EquipmentType)
  let $filteredResults := $results[EquipmentType eq $type]
  let $count := fn:count($filteredResults)
  return
    element object {
      element EquipmentType { $type },
      element CountOfAppointments { $count }
    }

return element Result { $groupedResults }












11)Total Appointments for X date group by Vessels

xquery version "1.0-ml";

let $currentDate := fn:current-date()

let $results :=
  for $appointment in fn:collection("Appointment")
  let $appointmentType := $appointment/AppointmentType/text()
  let $VesselID := $appointment/VesselID/text()
  where fn:starts-with($appointment/ScheduledStartDate/text(), $currentDate)
  return
    element object {
      element AppointmentType { $appointmentType },
      element VesselID { $VesselID },
      element ScheduleStartDate { $appointment/ScheduledStartDate/text() }
    }

 
let $groupedResults :=
  for $i in fn:distinct-values($results/VesselID)
  let $filteredResults := $results[VesselID eq $i]
  let $count := fn:count($filteredResults)
  return
    element object {
      element VesselID { $i },
      element CountOfAppointments { $count }
    }

return element Result { $groupedResults }















12)Total shipments Unloading in real time

let $currentDate := fn:current-date()

let $results :=
  element result{
  for $appointment in fn:collection("Appointment")
  let $id := $appointment/InventoryId
  let $shipments :=
    for $shipment in fn:collection("Shipments and Inventory")
    where $shipment/InventoryId eq $id
    return $shipment
  where $appointment/type eq 'Unload' and $appointment/ScheduledStartDate eq $currentDate
  return element shipments {$shipments}
}

return
  element results{
    for $i in $results/*
    let $count := fn:count($i)
    return 
      (  
        element inventoryId{ $i/InventoryId },
        element count{$count}
      )
  }













14)Total available appointment slots for unloading    - X day (user to select)

declare variable $days as xs:integer external;

let $current-date := current-dateTime()
let $end-date := $current-date + xs:dayTimeDuration(concat('P', xs:int($days), 'D'))

let $appointments :=
  for $appointment in collection("Appointment")/Appointments/Appointment
  where $appointment/AppointmentType = "Unload" 
        and xs:dateTime($appointment/ScheduledStartDateTime) >= $current-date
        and xs:dateTime($appointment/ScheduledEndDateTime) <= $end-date
  return $appointment

let $total-appointments := count($appointments)

return
  element result {
    element totalAppointments { $total-appointments },
    for $appointment in $appointments
    return element appointment {
      element AppointmentId { $appointment/AppointmentId/text() },
      element ScheduledStartDateTime { $appointment/ScheduledStartDateTime },
      element ScheduledEndDateTime { $appointment/ScheduledEndDateTime }
    }
  }















15)shipments not matching IB/OB grading 

element result{
  for $vessel in collection("Vessel Lineup Inventory")
  let $id := $vessel//InventoryId
  let $shipments :=
    for $inventory in collection("Shipments and Inventory")
    where $inventory//InventoryId eq $id
    return (element InventoryId{$inventory//InventoryId}, element InventoryType{$inventory//InventoryType})
  where $vessel//LoadGrade ne $vessel//UnloadGrade
  return element shipment {$shipments}
}















17)commodity - grade - inventory position - status - availability  date  (Current)

let $Date := fn:current-date()

let $Shipments := collection('Shipments and Inventory')[xs:date(xs:dateTime(.//ActualShipmentDestinationArrivalDateTime)) eq $Date]

return element result{
for $status in fn:distinct-values($Shipments//status)
let $shipment := $Shipments[.//status eq $status]
  for $i in $shipment
  let $Commodity := $i//Commodity
  let $Grade     := $i//Grade
  let $date := $i//ActualShipmentDestinationArrivalDateTime
  return (element status {$status},element object{$Commodity, $Grade, $date})
}
























18)commodity - grade - inventory position - status - availability date - (future date) 

let $Date := fn:current-date()

let $Shipments := collection('Shipments and Inventory')[xs:date(xs:dateTime(.//EstimatedShipmentDestinationArrivalDateTime)) > $Date]

return element result{
for $status in fn:distinct-values($Shipments//status)
let $shipment := $Shipments[.//status eq $status]
  for $i in $shipment
  let $Commodity := $i//Commodity
  let $Grade     := $i//Grade
  let $Date := $i//EstimatedShipmentDestinationArrivalDateTime
  return (element status {$status},element shipment{$Commodity, $Grade, $Date})
}
















19)Overall view of Inventories assigned to a Vessel and Vessel Journey

let $Vessels := collection('Vessel Lineup Inventory')
let $Shipments := collection('Shipments and Inventory')
let $Appointments := collection('Appointment')

return 
element result{
for $vessel in $Vessels
let $shipment := $Shipments[.//InventoryId eq $vessel//InventoryId]
let $appointment := $Appointments[.//InventoryId eq shipment//InventoryId and .//VesselId eq $vessel//VesselId]

let $vesselId := $vessel//VesselId
let $journeyId := $vessel//JourneyId
let $inventoryId := $vessel//InventoryId
let $inventoryType := $vessel//InventoryType

let $shipmentStatus := $shipment//ShipmentStatus

let $appointmentType := $appointment//AppointmentType
let $appointmentStatus := $appointment//AppointmentStatus

return (element object{element column1{$appointmentType,$appointmentStatus},element column2{$vesselId,$journeyId,$inventoryId,$inventoryType,$shipmentStatus}})
}