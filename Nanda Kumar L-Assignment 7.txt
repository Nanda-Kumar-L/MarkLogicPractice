xquery version "1.0-ml";
(:
let $json2 := '((C1 and C2) or C3)'
cts:or((cts:and-query((cts:path, cts:path)), cts:path))
:)

declare function local:convert($input as xs:string) as xs:string {
  let $map := map:map()
  let $_ := map:put($map, "and", 'cts:and-query')
  let $_ := map:put($map, "or", "cts:or-query")
  let $_ := map:put($map, "{", "(")
  let $_ := map:put($map, "[", "(")
  let $_ := map:put($map, "}", ")")
  let $_ := map:put($map, "]", ")")
  let $_ := map:put($map, '"', "")
  let $_ := map:put($map, 'condition', "")
  let $_ := map:put($map, ':', "")
  let $_ := map:put($map, 'field', "cts:path-range-query(/")
  let $_ := map:put($map, 'operator', "")
  let $_ := map:put($map, 'null', "")
  let $_ := map:put($map, 'rules', "")
  let $tokens := cts:tokenize($input)
  let $converted := 
    for $i at $x in $tokens
    return
      if (map:contains($map, $i)) then
      
        if(map:get($map, $i)) then 
           if($tokens[$x]='{' and ($tokens[($x)-2]='}' or $x=1)) then ""
           else map:get($map, $i)
        else
        map:get($map, $i)
      else if($i=',') then
          if($tokens[$x+1]='{') then
            "," else ""
      else
        $i
  return fn:string-join($converted, "")
};

let $json_ori :='{
  "condition": "and",
  "rules": [
    {"field": "C1", "operator": null},
    {"field": "C2", "operator": null},
    {
      "condition": "or",
      "rules": [
        {
          "condition": "and",
          "rules": [
            {"field": "C3", "operator": null},
            {"field": "C6", "operator": null}
          ]
        },
        {
          "condition": "and",
          "rules": [
            {"field": "C4", "operator": null},
            {"field": "C5", "operator": null}
          ]
        }
      ]
    }
  ]
}'

let $json := fn:string-join(fn:tokenize(fn:normalize-space(fn:string-join(fn:tokenize($json_ori, " "),
               "")), " "),
               "")
               
return local:convert($json)


