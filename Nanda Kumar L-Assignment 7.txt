xquery version "1.0-ml";
(:
let $json2 := '((C1 and C2) or C3)'
cts:or((cts:and-query((cts:path, cts:path)), cts:path))
:)

declare function local:json-to-cts($json as map:map){
  let $condition := map:get($json, "condition")
  let $rules := map:get($json, "rules")
  return 
    if ($condition eq "and") then
      cts:and-query(
        for $rule at $x in json:array-values($rules)
        return
          if (map:contains($rule, "condition")) then
            local:json-to-cts($rule)
          else(
               cts:path-range-query(map:get($rule, "field"), map:get($rule, "operator"), map:get($rule, "value"))
            )
      )
    else if ($condition eq "or") then
      cts:or-query(
        for $rule at $x in json:array-values($rules)
        return
          if (map:contains($rule, "condition")) then
            local:json-to-cts($rule)
          else(
              cts:path-range-query(map:get($rule, "field"), map:get($rule, "operator"), map:get($rule, "value"))
            )
      )
      else ()
};


let $JSON := xdmp:from-json-string('{
  "condition": "and",
  "rules": [
    {"field": "C1", "operator": "=", "value": "some_value"},
    {"field": "C2", "operator": ">=", "value": "some_value"},
    {
      "condition": "or",
      "rules": [
        {
          "condition": "and",
          "rules": [
            {"field": "C3", "operator": ">", "value": 10},
            {"field": "C6", "operator": "<", "value": 20}
          ]
        },
        {
          "condition": "and",
          "rules": [
            {"field": "C4", "operator": "<=", "value": 50},
            {"field": "C5", "operator": "!=", "value": "exclude_value"}
          ]
        }
      ]
    }
  ]
}')

let $cts-query := local:json-to-cts($JSON)
return
  $cts-query



